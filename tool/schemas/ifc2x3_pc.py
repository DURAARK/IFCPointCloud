import os
from pyparsing import *
from nodes import *

ABS = (CaselessKeyword("abs"))
ABSTRACT = (CaselessKeyword("abstract"))
ACOS = (CaselessKeyword("acos"))
AGGREGATE = (CaselessKeyword("aggregate"))
ALIAS = (CaselessKeyword("alias"))
AND = (CaselessKeyword("and"))
ANDOR = (CaselessKeyword("andor"))
ARRAY = (CaselessKeyword("array"))
AS = (CaselessKeyword("as"))
ASIN = (CaselessKeyword("asin"))
ATAN = (CaselessKeyword("atan"))
BAG = (CaselessKeyword("bag"))
BASED_ON = (CaselessKeyword("based_on"))
BEGIN = (CaselessKeyword("begin"))
BINARY = (CaselessKeyword("binary"))
BLENGTH = (CaselessKeyword("blength"))
BOOLEAN = (CaselessKeyword("boolean"))
BY = (CaselessKeyword("by"))
CASE = (CaselessKeyword("case"))
CONSTANT = (CaselessKeyword("constant"))
CONST_E = (CaselessKeyword("const_e"))
COS = (CaselessKeyword("cos"))
DERIVE = (CaselessKeyword("derive"))
DIV = (CaselessKeyword("div"))
ELSE = (CaselessKeyword("else"))
END = (CaselessKeyword("end"))
END_ALIAS = (CaselessKeyword("end_alias"))
END_CASE = (CaselessKeyword("end_case"))
END_CONSTANT = (CaselessKeyword("end_constant"))
END_ENTITY = (CaselessKeyword("end_entity"))
END_FUNCTION = (CaselessKeyword("end_function"))
END_IF = (CaselessKeyword("end_if"))
END_LOCAL = (CaselessKeyword("end_local"))
END_PROCEDURE = (CaselessKeyword("end_procedure"))
END_REPEAT = (CaselessKeyword("end_repeat"))
END_RULE = (CaselessKeyword("end_rule"))
END_SCHEMA = (CaselessKeyword("end_schema"))
END_SUBTYPE_CONSTRAINT = (CaselessKeyword("end_subtype_constraint"))
END_TYPE = (CaselessKeyword("end_type"))
ENTITY = (CaselessKeyword("entity"))
ENUMERATION = (CaselessKeyword("enumeration"))
ESCAPE = (CaselessKeyword("escape"))
EXISTS = (CaselessKeyword("exists"))
EXTENSIBLE = (CaselessKeyword("extensible"))
EXP = (CaselessKeyword("exp"))
FALSE = (CaselessKeyword("false"))
FIXED = (CaselessKeyword("fixed"))
FOR = (CaselessKeyword("for"))
FORMAT = (CaselessKeyword("format"))
FROM = (CaselessKeyword("from"))
FUNCTION = (CaselessKeyword("function"))
GENERIC = (CaselessKeyword("generic"))
GENERIC_ENTITY = (CaselessKeyword("generic_entity"))
HIBOUND = (CaselessKeyword("hibound"))
HIINDEX = (CaselessKeyword("hiindex"))
IF = (CaselessKeyword("if"))
IN = (CaselessKeyword("in"))
INSERT = (CaselessKeyword("insert"))
INTEGER = (CaselessKeyword("integer"))
INVERSE = (CaselessKeyword("inverse"))
LENGTH = (CaselessKeyword("length"))
LIKE = (CaselessKeyword("like"))
LIST = (CaselessKeyword("list"))
LOBOUND = (CaselessKeyword("lobound"))
LOCAL = (CaselessKeyword("local"))
LOG = (CaselessKeyword("log"))
LOG10 = (CaselessKeyword("log10"))
LOG2 = (CaselessKeyword("log2"))
LOGICAL = (CaselessKeyword("logical"))
LOINDEX = (CaselessKeyword("loindex"))
MOD = (CaselessKeyword("mod"))
NOT = (CaselessKeyword("not"))
NUMBER = (CaselessKeyword("number"))
NVL = (CaselessKeyword("nvl"))
ODD = (CaselessKeyword("odd"))
OF = (CaselessKeyword("of"))
ONEOF = (CaselessKeyword("oneof"))
OPTIONAL = (CaselessKeyword("optional"))
OR = (CaselessKeyword("or"))
OTHERWISE = (CaselessKeyword("otherwise"))
PI = (CaselessKeyword("pi"))
PROCEDURE = (CaselessKeyword("procedure"))
QUERY = (CaselessKeyword("query"))
REAL = (CaselessKeyword("real"))
REFERENCE = (CaselessKeyword("reference"))
REMOVE = (CaselessKeyword("remove"))
RENAMED = (CaselessKeyword("renamed"))
REPEAT = (CaselessKeyword("repeat"))
RETURN = (CaselessKeyword("return"))
ROLESOF = (CaselessKeyword("rolesof"))
RULE = (CaselessKeyword("rule"))
SCHEMA = (CaselessKeyword("schema"))
SELECT = (CaselessKeyword("select"))
SELF = (CaselessKeyword("self"))
SET = (CaselessKeyword("set"))
SIN = (CaselessKeyword("sin"))
SIZEOF = (CaselessKeyword("sizeof"))
SKIP = (CaselessKeyword("skip"))
SQRT = (CaselessKeyword("sqrt"))
STRING = (CaselessKeyword("string"))
SUBTYPE = (CaselessKeyword("subtype"))
SUBTYPE_CONSTRAINT = (CaselessKeyword("subtype_constraint"))
SUPERTYPE = (CaselessKeyword("supertype"))
TAN = (CaselessKeyword("tan"))
THEN = (CaselessKeyword("then"))
TO = (CaselessKeyword("to"))
TOTAL_OVER = (CaselessKeyword("total_over"))
TRUE = (CaselessKeyword("true"))
TYPE = (CaselessKeyword("type"))
TYPEOF = (CaselessKeyword("typeof"))
UNIQUE = (CaselessKeyword("unique"))
UNKNOWN = (CaselessKeyword("unknown"))
UNTIL = (CaselessKeyword("until"))
USE = (CaselessKeyword("use"))
USEDIN = (CaselessKeyword("usedin"))
VALUE = (CaselessKeyword("value"))
VALUE_IN = (CaselessKeyword("value_in"))
VALUE_UNIQUE = (CaselessKeyword("value_unique"))
VAR = (CaselessKeyword("var"))
WHERE = (CaselessKeyword("where"))
WHILE = (CaselessKeyword("while"))
WITH = (CaselessKeyword("with"))
XOR = (CaselessKeyword("xor"))
bit = ((CaselessLiteral("0") | CaselessLiteral("1")))
digit = ((CaselessLiteral("0") | CaselessLiteral("1") | CaselessLiteral("2") | CaselessLiteral("3") | CaselessLiteral("4") | CaselessLiteral("5") | CaselessLiteral("6") | CaselessLiteral("7") | CaselessLiteral("8") | CaselessLiteral("9")))
digits = ((digit + ZeroOrMore(digit)))
hex_digit = ((digit | CaselessLiteral("a") | CaselessLiteral("b") | CaselessLiteral("c") | CaselessLiteral("d") | CaselessLiteral("e") | CaselessLiteral("f")))
letter = ((CaselessLiteral("a") | CaselessLiteral("b") | CaselessLiteral("c") | CaselessLiteral("d") | CaselessLiteral("e") | CaselessLiteral("f") | CaselessLiteral("g") | CaselessLiteral("h") | CaselessLiteral("i") | CaselessLiteral("j") | CaselessLiteral("k") | CaselessLiteral("l") | CaselessLiteral("m") | CaselessLiteral("n") | CaselessLiteral("o") | CaselessLiteral("p") | CaselessLiteral("q") | CaselessLiteral("r") | CaselessLiteral("s") | CaselessLiteral("t") | CaselessLiteral("u") | CaselessLiteral("v") | CaselessLiteral("w") | CaselessLiteral("x") | CaselessLiteral("y") | CaselessLiteral("z")))
not_paren_star_quote_special = ((CaselessLiteral("!") | CaselessLiteral("#") | CaselessLiteral("$") | CaselessLiteral("%") | CaselessLiteral("&") | CaselessLiteral("+") | CaselessLiteral(",") | CaselessLiteral("-") | CaselessLiteral(".") | CaselessLiteral("/") | CaselessLiteral(":") | CaselessLiteral(";") | CaselessLiteral("<") | CaselessLiteral("=") | CaselessLiteral(">") | CaselessLiteral("?") | CaselessLiteral("@") | CaselessLiteral("[") | CaselessLiteral("\\") | CaselessLiteral("]") | CaselessLiteral("^") | CaselessLiteral("_") | CaselessLiteral("{") | CaselessLiteral("|") | CaselessLiteral("}") | CaselessLiteral("~")))
not_paren_star_special = ((not_paren_star_quote_special | CaselessLiteral("\"\"")))
not_quote = ((not_paren_star_quote_special | letter | digit | CaselessLiteral("(") | CaselessLiteral(")") | CaselessLiteral("*")))
octet = ((hex_digit + hex_digit))
special = ((not_paren_star_quote_special | CaselessLiteral("(") | CaselessLiteral(")") | CaselessLiteral("*") | CaselessLiteral("\"\"")))
binary_literal = ((CaselessLiteral("%") + bit + ZeroOrMore(bit)))
integer_literal = (digits)
simple_id = originalTextFor(Combine((letter + ZeroOrMore((letter | digit | CaselessLiteral("_"))))))
simple_string_literal = ((CaselessLiteral("'") + ZeroOrMore(((CaselessLiteral("'") + CaselessLiteral("'")) | not_quote)) + CaselessLiteral("'")))
abstract_entity_declaration = (ABSTRACT)
abstract_supertype = ((ABSTRACT + SUPERTYPE + CaselessLiteral(";")))
add_like_op = ((CaselessLiteral("+") | CaselessLiteral("-") | OR | XOR))
attribute_id = (simple_id)
boolean_type = (BOOLEAN)
built_in_constant = ((CONST_E | PI | SELF | CaselessLiteral("?")))
built_in_function = ((ABS | ACOS | ASIN | ATAN | BLENGTH | COS | EXISTS | EXP | FORMAT | HIBOUND | HIINDEX | LENGTH | LOBOUND | LOINDEX | LOG | LOG2 | LOG10 | NVL | ODD | ROLESOF | SIN | SIZEOF | SQRT | TAN | TYPEOF | USEDIN | VALUE | VALUE_IN | VALUE_UNIQUE))
built_in_procedure = ((INSERT | REMOVE))
constant_id = (simple_id)
entity_id = (simple_id)
enumeration_id = (simple_id)
enumeration_items = ((CaselessLiteral("(") + enumeration_id + ZeroOrMore((CaselessLiteral(",") + enumeration_id)) + CaselessLiteral(")")))
escape_stmt = ((ESCAPE + CaselessLiteral(";")))
function_id = (simple_id)
integer_type = (INTEGER)
interval_op = ((CaselessLiteral("<=") | CaselessLiteral("<")))
logical_literal = ((FALSE | TRUE | UNKNOWN))
logical_type = (LOGICAL)
multiplication_like_op = ((CaselessLiteral("*") | CaselessLiteral("/") | DIV | MOD | AND | CaselessLiteral("||")))
null_stmt = (CaselessLiteral(";"))
number_type = (NUMBER)
parameter_id = (simple_id)
procedure_id = (simple_id)
rel_op = ((CaselessLiteral("<=") | CaselessLiteral(">=") | CaselessLiteral("<>") | CaselessLiteral("=") | CaselessLiteral(":<>:") | CaselessLiteral(":=:") | CaselessLiteral("<") | CaselessLiteral(">")))
rel_op_extended = ((rel_op | IN | LIKE))
rule_id = (simple_id)
rule_label_id = (simple_id)
schema_id = (simple_id)
sign = ((CaselessLiteral("+") | CaselessLiteral("-")))
skip_stmt = ((SKIP + CaselessLiteral(";")))
subtype_constraint_id = (simple_id)
type_id = (simple_id)
type_label_id = (simple_id)
unary_op = ((CaselessLiteral("+") | CaselessLiteral("-") | NOT))
variable_id = (simple_id)
encoded_character = ((octet + octet + octet + octet))
not_paren_star = ((letter | digit | not_paren_star_special))
not_rparen_star = ((not_paren_star | CaselessLiteral("(")))
not_rparen_star_then_rparen = ((not_rparen_star + ZeroOrMore(not_rparen_star) + CaselessLiteral(")") + ZeroOrMore(CaselessLiteral(")"))))
encoded_string_literal = ((CaselessLiteral("\"") + encoded_character + ZeroOrMore(encoded_character) + CaselessLiteral("\"")))
real_literal = (((digits + CaselessLiteral(".") + Optional(digits) + Optional((CaselessLiteral("e") + Optional(sign) + digits))) | integer_literal))
attribute_ref = (attribute_id)
constant_ref = (constant_id)
entity_ref = (entity_id)
enumeration_ref = (enumeration_id)
function_ref = (function_id)
parameter_ref = (parameter_id)
procedure_ref = (procedure_id)
rule_label_ref = (rule_label_id)
rule_ref = (rule_id)
schema_ref = (schema_id)
subtype_constraint_ref = (subtype_constraint_id)
type_label_ref = (type_label_id)
type_ref = (type_id)
variable_ref = (variable_id)
attribute_qualifier = ((CaselessLiteral(".") + attribute_ref))
constant_factor = ((built_in_constant | constant_ref))
enumeration_extension = ((BASED_ON + type_ref + Optional((WITH + enumeration_items))))
enumeration_reference = ((Optional((type_ref + CaselessLiteral("."))) + enumeration_ref))
enumeration_type = ((Optional(EXTENSIBLE) + ENUMERATION + Optional(((OF + enumeration_items) | enumeration_extension)))).setParseAction(lambda t: EnumerationType(t))
general_ref = ((parameter_ref | variable_ref))
group_qualifier = ((CaselessLiteral("\\") + entity_ref))
named_types = ((entity_ref | type_ref))
named_type_or_rename = ((named_types + Optional((AS + (entity_id | type_id)))))
population = (entity_ref)
qualified_attribute = ((SELF + group_qualifier + attribute_qualifier))
redeclared_attribute = ((qualified_attribute + Optional((RENAMED + attribute_id))))
referenced_attribute = ((attribute_ref | qualified_attribute))
rename_id = ((constant_id | entity_id | function_id | procedure_id | type_id))
resource_ref = ((constant_ref | entity_ref | function_ref | procedure_ref | type_ref))
rule_head = ((RULE + rule_id + FOR + CaselessLiteral("(") + entity_ref + ZeroOrMore((CaselessLiteral(",") + entity_ref)) + CaselessLiteral(")") + CaselessLiteral(";")))
select_list = ((CaselessLiteral("(") + named_types + ZeroOrMore((CaselessLiteral(",") + named_types)) + CaselessLiteral(")")))
string_literal = ((simple_string_literal | encoded_string_literal))
subtype_constraint_head = ((SUBTYPE_CONSTRAINT + subtype_constraint_id + FOR + entity_ref + CaselessLiteral(";")))
subtype_declaration = ((SUBTYPE + OF + CaselessLiteral("(") + entity_ref + ZeroOrMore((CaselessLiteral(",") + entity_ref)) + CaselessLiteral(")"))).setParseAction(lambda t: SubtypeExpression(t))
total_over = ((TOTAL_OVER + CaselessLiteral("(") + entity_ref + ZeroOrMore((CaselessLiteral(",") + entity_ref)) + CaselessLiteral(")") + CaselessLiteral(";")))
type_label = ((type_label_id | type_label_ref))
unique_rule = ((rule_label_id + CaselessLiteral(":") + referenced_attribute + ZeroOrMore((CaselessLiteral(",") + referenced_attribute))))
use_clause = ((USE + FROM + schema_ref + Optional((CaselessLiteral("(") + named_type_or_rename + ZeroOrMore((CaselessLiteral(",") + named_type_or_rename)) + CaselessLiteral(")"))) + CaselessLiteral(";")))
not_lparen_star = ((not_paren_star | CaselessLiteral(")")))
remark_ref = ((attribute_ref | constant_ref | entity_ref | enumeration_ref | function_ref | parameter_ref | procedure_ref | rule_label_ref | rule_ref | schema_ref | subtype_constraint_ref | type_label_ref | type_ref | variable_ref))
attribute_decl = ((redeclared_attribute | attribute_id))
generic_entity_type = ((GENERIC_ENTITY + Optional((CaselessLiteral(":") + type_label))))
generic_type = ((GENERIC + Optional((CaselessLiteral(":") + type_label))))
literal = ((binary_literal | logical_literal | real_literal | string_literal))
resource_or_rename = ((resource_ref + Optional((AS + rename_id))))
schema_version_id = (string_literal)
select_extension = ((BASED_ON + type_ref + Optional((WITH + select_list))))
select_type = ((Optional((EXTENSIBLE + Optional(GENERIC_ENTITY))) + SELECT + Optional((select_list | select_extension)))).setParseAction(lambda t: SelectType(t))
unique_clause = ((UNIQUE + unique_rule + CaselessLiteral(";") + ZeroOrMore((unique_rule + CaselessLiteral(";")))))
lparen_then_not_lparen_star = ((CaselessLiteral("(") + ZeroOrMore(CaselessLiteral("(")) + not_lparen_star + ZeroOrMore(not_lparen_star)))
remark_tag = ((CaselessLiteral("\"") + remark_ref + ZeroOrMore((CaselessLiteral(".") + remark_ref)) + CaselessLiteral("\"")))
tail_remark = ((CaselessLiteral("--") + Optional(remark_tag)))
constructed_types = ((enumeration_type | select_type))
reference_clause = ((REFERENCE + FROM + schema_ref + Optional((CaselessLiteral("(") + resource_or_rename + ZeroOrMore((CaselessLiteral(",") + resource_or_rename)) + CaselessLiteral(")"))) + CaselessLiteral(";")))
interface_specification = ((reference_clause | use_clause))
string_type = Forward()
rule_decl = Forward()
supertype_constraint = Forward()
interval = Forward()
supertype_term = Forward()
stmt = Forward()
qualifiable_factor = Forward()
bag_type = Forward()
procedure_head = Forward()
repeat_control = Forward()
simple_factor = Forward()
general_set_type = Forward()
supertype_factor = Forward()
if_stmt = Forward()
precision_spec = Forward()
procedure_decl = Forward()
remark = Forward()
entity_constructor = Forward()
repeat_stmt = Forward()
real_type = Forward()
term = Forward()
general_list_type = Forward()
abstract_supertype_declaration = Forward()
primary = Forward()
concrete_types = Forward()
expression = Forward()
index = Forward()
simple_expression = Forward()
supertype_rule = Forward()
declaration = Forward()
increment_control = Forward()
entity_head = Forward()
case_label = Forward()
local_decl = Forward()
procedure_call_stmt = Forward()
syntax = Forward()
general_bag_type = Forward()
index_2 = Forward()
index_1 = Forward()
element = Forward()
parameter_type = Forward()
width = Forward()
parameter = Forward()
aggregate_source = Forward()
selector = Forward()
subsuper = Forward()
interval_item = Forward()
subtype_constraint_body = Forward()
interval_high = Forward()
factor = Forward()
subtype_constraint = Forward()
subtype_constraint_decl = Forward()
simple_types = Forward()
assignment_stmt = Forward()
compound_stmt = Forward()
where_clause = Forward()
interval_low = Forward()
schema_body = Forward()
constant_decl = Forward()
while_control = Forward()
function_decl = Forward()
actual_parameter_list = Forward()
underlying_type = Forward().setParseAction(lambda t: UnderlyingType(t))
aggregate_type = Forward()
domain_rule = Forward()
generalized_types = Forward()
array_type = Forward()
general_array_type = Forward()
function_head = Forward()
local_variable = Forward()
instantiable_type = Forward()
type_decl = Forward().setParseAction(lambda t: TypeDeclaration(t))
formal_parameter = Forward()
binary_type = Forward().setParseAction(lambda t: BinaryType(t))
constant_body = Forward()
supertype_expression = Forward()
list_type = Forward()
entity_decl = Forward().setParseAction(lambda t: EntityDeclaration(t))
until_control = Forward()
numeric_expression = Forward()
algorithm_head = Forward()
derived_attr = Forward().setParseAction(lambda t: DerivedAttribute(t))
entity_body = Forward()
query_expression = Forward()
width_spec = Forward()
schema_decl = Forward()
general_aggregation_types = Forward().setParseAction(lambda t: AggregationType(t))
repetition = Forward()
derive_clause = Forward().setParseAction(lambda t: AttributeList('derive', t))
case_stmt = Forward()
alias_stmt = Forward()
qualifier = Forward()
inverse_clause = Forward().setParseAction(lambda t: AttributeList('inverse', t))
aggregate_initializer = Forward()
embedded_remark = Forward()
bound_2 = Forward()
bound_1 = Forward()
case_action = Forward()
function_call = Forward()
logical_expression = Forward()
inverse_attr = Forward().setParseAction(lambda t: InverseAttribute(t))
one_of = Forward()
return_stmt = Forward()
index_qualifier = Forward()
increment = Forward()
explicit_attr = Forward().setParseAction(lambda t: ExplicitAttribute(t))
bound_spec = Forward().setParseAction(lambda t: BoundSpecification(t))
set_type = Forward()
aggregation_types = Forward().setParseAction(lambda t: AggregationType(t))
string_type << ((STRING + Optional(width_spec)))
rule_decl << ((rule_head + algorithm_head + ZeroOrMore(stmt) + where_clause + END_RULE + CaselessLiteral(";")))
supertype_constraint << ((abstract_supertype_declaration | abstract_entity_declaration | supertype_rule))
interval << ((CaselessLiteral("{") + interval_low + interval_op + interval_item + interval_op + interval_high + CaselessLiteral("}")))
supertype_term << ((one_of | (CaselessLiteral("(") + supertype_expression + CaselessLiteral(")")) | entity_ref))
stmt << ((alias_stmt | assignment_stmt | case_stmt | compound_stmt | escape_stmt | if_stmt | null_stmt | procedure_call_stmt | repeat_stmt | return_stmt | skip_stmt))
qualifiable_factor << ((function_call | attribute_ref | constant_factor | general_ref | population))
bag_type << ((BAG + Optional(bound_spec) + OF + instantiable_type))
procedure_head << ((PROCEDURE + procedure_id + Optional((CaselessLiteral("(") + Optional(VAR) + formal_parameter + ZeroOrMore((CaselessLiteral(";") + Optional(VAR) + formal_parameter)) + CaselessLiteral(")"))) + CaselessLiteral(";")))
repeat_control << ((Optional(increment_control) + Optional(while_control) + Optional(until_control)))
simple_factor << ((aggregate_initializer | interval | query_expression | (Optional(unary_op) + ((CaselessLiteral("(") + expression + CaselessLiteral(")")) | primary)) | entity_constructor | enumeration_reference))
general_set_type << ((SET + Optional(bound_spec) + OF + parameter_type))
supertype_factor << ((supertype_term + ZeroOrMore((AND + supertype_term))))
if_stmt << ((IF + logical_expression + THEN + stmt + ZeroOrMore(stmt) + Optional((ELSE + stmt + ZeroOrMore(stmt))) + END_IF + CaselessLiteral(";")))
precision_spec << (numeric_expression)
procedure_decl << ((procedure_head + algorithm_head + ZeroOrMore(stmt) + END_PROCEDURE + CaselessLiteral(";")))
remark << ((embedded_remark | tail_remark))
entity_constructor << ((entity_ref + CaselessLiteral("(") + Optional((expression + ZeroOrMore((CaselessLiteral(",") + expression)))) + CaselessLiteral(")")))
repeat_stmt << ((REPEAT + repeat_control + CaselessLiteral(";") + stmt + ZeroOrMore(stmt) + END_REPEAT + CaselessLiteral(";")))
real_type << ((REAL + Optional((CaselessLiteral("(") + precision_spec + CaselessLiteral(")")))))
term << ((factor + ZeroOrMore((multiplication_like_op + factor))))
general_list_type << ((LIST + Optional(bound_spec) + OF + Optional(UNIQUE) + parameter_type))
abstract_supertype_declaration << ((ABSTRACT + SUPERTYPE + Optional(subtype_constraint)))
primary << ((literal | (qualifiable_factor + ZeroOrMore(qualifier))))
concrete_types << ((aggregation_types | simple_types | type_ref))
expression << ((simple_expression + Optional((rel_op_extended + simple_expression))))
index << (numeric_expression)
simple_expression << ((term + ZeroOrMore((add_like_op + term))))
supertype_rule << ((SUPERTYPE + subtype_constraint))
declaration << ((entity_decl | function_decl | procedure_decl | subtype_constraint_decl | type_decl))
increment_control << ((variable_id + CaselessLiteral(":=") + bound_1 + TO + bound_2 + Optional((BY + increment))))
entity_head << ((ENTITY + entity_id + subsuper + CaselessLiteral(";")))
case_label << (expression)
local_decl << ((LOCAL + local_variable + ZeroOrMore(local_variable) + END_LOCAL + CaselessLiteral(";")))
procedure_call_stmt << (((built_in_procedure | procedure_ref) + actual_parameter_list + CaselessLiteral(";")))
syntax << ((schema_decl + ZeroOrMore(schema_decl)))
general_bag_type << ((BAG + Optional(bound_spec) + OF + parameter_type))
index_2 << (index)
index_1 << (index)
element << ((expression + Optional((CaselessLiteral(":") + repetition))))
parameter_type << ((generalized_types | simple_types | named_types))
width << (numeric_expression)
parameter << (expression)
aggregate_source << (simple_expression)
selector << (expression)
subsuper << ((Optional(supertype_constraint) + Optional(subtype_declaration)))
interval_item << (simple_expression)
subtype_constraint_body << ((Optional(abstract_supertype) + Optional(total_over) + Optional((supertype_expression + CaselessLiteral(";")))))
interval_high << (simple_expression)
factor << ((simple_factor + Optional((CaselessLiteral("**") + simple_factor))))
subtype_constraint << ((OF + CaselessLiteral("(") + supertype_expression + CaselessLiteral(")")))
subtype_constraint_decl << ((subtype_constraint_head + subtype_constraint_body + END_SUBTYPE_CONSTRAINT + CaselessLiteral(";")))
simple_types << ((binary_type | boolean_type | integer_type | logical_type | number_type | real_type | string_type))
assignment_stmt << ((general_ref + ZeroOrMore(qualifier) + CaselessLiteral(":=") + expression + CaselessLiteral(";")))
compound_stmt << ((BEGIN + stmt + ZeroOrMore(stmt) + END + CaselessLiteral(";")))
where_clause << ((WHERE + domain_rule + CaselessLiteral(";") + ZeroOrMore((domain_rule + CaselessLiteral(";")))))
interval_low << (simple_expression)
schema_body << ((ZeroOrMore(interface_specification) + Optional(constant_decl) + ZeroOrMore((declaration | rule_decl))))
constant_decl << ((CONSTANT + constant_body + ZeroOrMore(constant_body) + END_CONSTANT + CaselessLiteral(";")))
while_control << ((WHILE + logical_expression))
function_decl << ((function_head + algorithm_head + stmt + ZeroOrMore(stmt) + END_FUNCTION + CaselessLiteral(";")))
actual_parameter_list << ((CaselessLiteral("(") + Optional(parameter) + ZeroOrMore((CaselessLiteral(",") + parameter)) + CaselessLiteral(")")))
underlying_type << ((constructed_types | concrete_types))
aggregate_type << ((AGGREGATE + Optional((CaselessLiteral(":") + type_label)) + OF + parameter_type))
domain_rule << ((rule_label_id + CaselessLiteral(":") + expression))
generalized_types << ((aggregate_type | general_aggregation_types | generic_entity_type | generic_type))
array_type << ((ARRAY + bound_spec + OF + Optional(OPTIONAL) + Optional(UNIQUE) + instantiable_type))
general_array_type << ((ARRAY + Optional(bound_spec) + OF + Optional(OPTIONAL) + Optional(UNIQUE) + parameter_type))
function_head << ((FUNCTION + function_id + Optional((CaselessLiteral("(") + formal_parameter + ZeroOrMore((CaselessLiteral(";") + formal_parameter)) + CaselessLiteral(")"))) + CaselessLiteral(":") + parameter_type + CaselessLiteral(";")))
local_variable << ((variable_id + ZeroOrMore((CaselessLiteral(",") + variable_id)) + CaselessLiteral(":") + parameter_type + Optional((CaselessLiteral(":=") + expression)) + CaselessLiteral(";")))
instantiable_type << ((concrete_types | entity_ref))
type_decl << ((TYPE + type_id + CaselessLiteral("=") + underlying_type + CaselessLiteral(";") + Optional(where_clause) + END_TYPE + CaselessLiteral(";")))
formal_parameter << ((parameter_id + ZeroOrMore((CaselessLiteral(",") + parameter_id)) + CaselessLiteral(":") + parameter_type))
binary_type << ((BINARY + Optional(width_spec)))
constant_body << ((constant_id + CaselessLiteral(":") + instantiable_type + CaselessLiteral(":=") + expression + CaselessLiteral(";")))
supertype_expression << ((supertype_factor + ZeroOrMore((ANDOR + supertype_factor))))
list_type << ((LIST + Optional(bound_spec) + OF + Optional(UNIQUE) + instantiable_type))
entity_decl << ((entity_head + entity_body + END_ENTITY + CaselessLiteral(";")))
until_control << ((UNTIL + logical_expression))
numeric_expression << (simple_expression)
algorithm_head << ((ZeroOrMore(declaration) + Optional(constant_decl) + Optional(local_decl)))
derived_attr << ((attribute_decl + CaselessLiteral(":") + parameter_type + CaselessLiteral(":=") + expression + CaselessLiteral(";")))
entity_body << ((ZeroOrMore(explicit_attr) + Optional(derive_clause) + Optional(inverse_clause) + Optional(unique_clause) + Optional(where_clause)))
query_expression << ((QUERY + CaselessLiteral("(") + variable_id + CaselessLiteral("<*") + aggregate_source + CaselessLiteral("|") + logical_expression + CaselessLiteral(")")))
width_spec << ((CaselessLiteral("(") + width + CaselessLiteral(")") + Optional(FIXED)))
schema_decl << ((SCHEMA + schema_id + Optional(schema_version_id) + CaselessLiteral(";") + schema_body + END_SCHEMA + CaselessLiteral(";")))
general_aggregation_types << ((general_array_type | general_bag_type | general_list_type | general_set_type))
repetition << (numeric_expression)
derive_clause << ((DERIVE + derived_attr + ZeroOrMore(derived_attr)))
case_stmt << ((CASE + selector + OF + ZeroOrMore(case_action) + Optional((OTHERWISE + CaselessLiteral(":") + stmt)) + END_CASE + CaselessLiteral(";")))
alias_stmt << ((ALIAS + variable_id + FOR + general_ref + ZeroOrMore(qualifier) + CaselessLiteral(";") + stmt + ZeroOrMore(stmt) + END_ALIAS + CaselessLiteral(";")))
qualifier << ((attribute_qualifier | group_qualifier | index_qualifier))
inverse_clause << ((INVERSE + inverse_attr + ZeroOrMore(inverse_attr)))
aggregate_initializer << ((CaselessLiteral("[") + Optional((element + ZeroOrMore((CaselessLiteral(",") + element)))) + CaselessLiteral("]")))
embedded_remark << ((CaselessLiteral("(*") + Optional(remark_tag) + ZeroOrMore(((not_paren_star + ZeroOrMore(not_paren_star)) | lparen_then_not_lparen_star | (CaselessLiteral("*") + ZeroOrMore(CaselessLiteral("*"))) | not_rparen_star_then_rparen | embedded_remark)) + CaselessLiteral("*)")))
bound_2 << (numeric_expression)
bound_1 << (numeric_expression)
case_action << ((case_label + ZeroOrMore((CaselessLiteral(",") + case_label)) + CaselessLiteral(":") + stmt))
function_call << (((built_in_function | function_ref) + actual_parameter_list))
logical_expression << (expression)
inverse_attr << ((attribute_decl + CaselessLiteral(":") + Optional(((SET | BAG) + Optional(bound_spec) + OF)) + entity_ref + FOR + Optional((entity_ref + CaselessLiteral("."))) + attribute_ref + CaselessLiteral(";")))
one_of << ((ONEOF + CaselessLiteral("(") + supertype_expression + ZeroOrMore((CaselessLiteral(",") + supertype_expression)) + CaselessLiteral(")")))
return_stmt << ((RETURN + Optional((CaselessLiteral("(") + expression + CaselessLiteral(")"))) + CaselessLiteral(";")))
index_qualifier << ((CaselessLiteral("[") + index_1 + Optional((CaselessLiteral(":") + index_2)) + CaselessLiteral("]")))
increment << (numeric_expression)
explicit_attr << ((attribute_decl + ZeroOrMore((CaselessLiteral(",") + attribute_decl)) + CaselessLiteral(":") + Optional(OPTIONAL) + parameter_type + CaselessLiteral(";")))
bound_spec << ((CaselessLiteral("[") + bound_1 + CaselessLiteral(":") + bound_2 + CaselessLiteral("]")))
set_type << ((SET + Optional(bound_spec) + OF + instantiable_type))
aggregation_types << ((array_type | bag_type | list_type | set_type))

import schema
import nodes

from collections import defaultdict

syntax.ignore(Regex(r"\((?:\*(?:[^*]*\*+)+?\))"))
ast = syntax.parseFile(os.path.join(os.path.dirname(__file__), "IFC2X3_TC1_PC.exp"))

schema = schema.Schema(ast)
